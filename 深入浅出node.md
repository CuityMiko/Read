# 深入浅出Node

# 1. Node简介

## 1.2 Node的命名和起源

Ryan Dahl是一名资深的c/c++程序员

他认为:设计高性能Web服务器的几个要点:

1. 事件驱动
2. 非阻塞IO

他的在选JS之前,其他语言的考虑

1. c门槛太高
2. haskell: 作者自己玩不6
3. lua: 自身已经有很多阻塞的库
4. Ruby: 性能不好

## 1.3 Node给javascript带来的意义

Node = Chrome - HTML - Webkit

## 1.4 Node的特点

### 1.4.1 异步I/O

### 1.4.2 事件与回调函数

事件的编程方式具有轻量级、轻耦合、只关注事物点等优势,但是在多个异步任务的场景下,事件和事件之间各自独立,如何协作是一个问题

### 1.4.3 单线程

优点: 

1. 不用像多线程那样处处在意状态同步问题
2. 不存在死锁
3. 不存在线程上下文交换带来的性能开销

缺点

1. 无法利用多核CPU
2. 错误会引起整个应用退出
3. 大量计算占用CPU导致无法继续调用异步I/O

在浏览器中主线程可以负责UI,而把大量的计算放在webworker

而Node,主线程负责响应,而可以child_process进行大量计算

这样

缺点1变成了: 可以利用多核进行大量计算
缺点3变成了: 可以利用多核进行计算

但是缺点2呢?.

## 1.5 Node的应用场景

### 1.5.1 I/O密集型

# 2. 模块机制

## 2.2 Node的模块实现

### 2.2.1 优先从缓存加载

其实无论是webpack还是浓的,都是从优先缓存读取的

所以require里的文件只会被第一次引用的时候执行,然后缓存起来

### 2.2.2 路径分析和文件定位

默认不带文件后缀时,会按.js,.json,.node
的顺序查找,所以一般只会隐藏.js,而.json,.node不会隐藏后缀

### 2.2.3 模块编译

1. .js: 通过fs模块同步读取后编译执行
2. .node: c/c++编写的拓展文件,通过dlopen()方法加载最后编译生成的文件
3. .json: 通过fs同步读取,然后JSON.parse()解析返回结果
4. 其余拓展名文件,会被当做js文件载入

# 3. 异步I/0

## 3.2 异步I/0实现现状

### 3.2.1 异步I/O与非阻塞I/O



