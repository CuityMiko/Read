# Wireshark网络分析的艺术

## 1. 读者问

### 像福尔摩斯一样思考

![](QQ20160929-1.png)

点击每一个包都会显示这些属性

1. Identification 如果第一次发过来0,以后一般都是0
2. TTL默认开始是64,而中间经过了多少代理就会-1



### 来点有深度的

延迟确认发生太多会影响性能

可通过`tcp.analysis.ack_rtt > 0.2 and tcp.len ==0`来显示出有可能延迟确认带来的包

![小米](QQ20160929-0.png)


这里我自己连接小米路由器的TCP,有非常多的小米延迟连接,所以我时候也会卡之类d的

### 三次握手的小知识

客户端->SYN seq=X ->服务器

客户端<-SYN seq=Y,Ack=X+1<-服务器

客户端->Seq=X+1 ACK=Y+1->服务器

![tcp](QQ20160930-0.png)

这个是我打开一个网页.然后捕抓src和dst为访问网页的IP

然后前3个就是3次握手

可以看看 Seq和ACK值的变化和我刚的描述变化是一样的

当然这个数字太长,可以默认初始值都为0

`Perferences->Protocols->TCP->勾选Relative Sequence Numbers`

这样设置后,成功的握手都是一样的,但是失败的握手就不一样了

失败握手一般分为两种情况

1. 被拒绝
2. 丢包

一般获取失败握手的表达式可以设置为

`(tcp.flags.reset==1) && (tcp.seq ==1)`

或者

过滤重传的握手请求: `(tcp.flags.syn == 1) && (tcp.analysis.retransmission)`

找到了之后,右键追踪TCP流

这是我的一个被拒绝得TCP流

![被拒绝的tcp](QQ20161008-0.png)

但是这样没办法判断丢包是

1. 没传到服务器就丢了
2. 还是服务器接受到了,但是回传的时候丢了

所以最好在客户端和服务器同时抓包

说说DDoS

原理就是大量主机发送SYN请求给服务器,假装建立TCP,这些SYN请求可能包含假的源地址,所以服务器永远收不到Ack,就会留下half-open的连接,每个TCP占用一定的系统资源,建立多了服务器资源就会被耗光

### 被误解的TCP

TCP并非每一个数据包都有对应的Ack

因为延迟确认可以多个包对应一个Ack


